#include <iostream>

using namespace std;

/*
* Упрощенный вектор
* */
template <typename T>
class TList {
  T* Data;
  size_t Size;
public:
  void Add(size_t pos, const T & val);
  T & Get(size_t pos);
  size_t GetSize() const;
};

/*
* Хотим написать класс множество, через описанный выше класс
* */
template <typename T>
class TSet {
public:
  void Add(const T &v);
  T & Get(size_t pos);
  size_t GetSize() const;
  bool IsExist(const T & v) const;
};
/*
* Стоит ли наследоваться?
* Определющим является вопрос: является ли TSet TList'ом
* Тогда ответ нет.
* Во-первых, можно сделать приватное наследование - но это не очень.
* Во-вторых, можно приватно хранить внутри TSet объект TList и использовать его методы
*
* Встает вопрос что лучше, наследование или аггрегация.
* Если бы этот класс обладал полиморфным поведением или был пустым (в котором нет данных), или
* содержал функционал, который должен был что-то сделать до всех остальных методов
* (напирмер, мьютекс) то стоило бы использовать наследование.
* */

/*
* Вообще, что такое объектно ориентированное программирование?
* Это методология и определения отличаются. Есть 4 принципа:
* 1) Абстаркция
*   важно как мы взаимодействуем с классом, а не так как класс реализован
* 2) Инкапсуляция
*   скрываем детали реализации
* 3) Наследование
* 4) Полиморфизм
* */

/*
* Идиома скрытой реализации.
* Пишем большую систему. Есть некоторый класс TLogger в logger.h.
* Хотим чтобы при его изменении не происходило перекомпиляции, ибо она длится несколько часов.
* У TLogger есть private TFile и public интерфейс AddMessage. Хотим поменять TFile на что-нибудь.
*
* Чтобы это сделать в TLogger не хранят TFile, а вместо него ссылку на имплементацию -  TImpl*
* Имплементация находится в logger.cpp будет
* class TLogger::TImpl{
* };
* и logger.cpp компилируется как отдельный модуль
*
*
* Такая идиома называется PImpl или Handle/Body
*
* Когда еще полезно использовать эту идиому?
* когда пишится код под разные платформы
* */

/*
* Паттерн "шаблонный метод"
* это не template в смысле языка c++
*
* есть базовый класс, который в некоторой последовательности делает определенные
* вещи
* */
/*
class TAbstractSolution {
  public:
    void Solve() {
      Initialize();
      for(...) {
        ReadDate();
        DoSolve();
        PrintResult();
      }
    }
};
*/
/*
* Все точки кастомизации выносим в закрытую секцию
* Non virtual public interface
* */
/*
class Task1: public TAbstracSolution{
private:
  virtual void Initialize() {

  }
  virtual void ReadData() {

  }
  ...
};*/


int main() {
  cout << "Hello, World!" << endl;
  return 0;
}
